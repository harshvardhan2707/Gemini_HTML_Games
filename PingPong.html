<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ping Pong Game</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a;
            color: #ffffff;
            overflow: hidden;
        }
        canvas {
            background-color: #000000;
            display: block;
            border: 4px solid #ffffff;
            border-radius: 8px;
        }
        .btn {
            background-color: #333;
            border: 2px solid #fff;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }
        .btn:hover {
            background-color: #555;
            transform: translateY(-2px);
        }
        .btn:disabled {
            background-color: #222;
            color: #666;
            cursor: not-allowed;
            border-color: #444;
        }
        .modal {
            background-color: rgba(0, 0, 0, 0.8);
            border: 4px solid #fff;
            border-radius: 10px;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center h-screen m-0">

    <div class="flex items-center justify-between w-full max-w-4xl mb-2 px-4">
        <h1 class="text-4xl">Ping Pong</h1>
        <button id="newGameBtn" class="btn text-lg hidden">New Game</button>
    </div>


    <!-- Scoreboard -->
    <div class="flex justify-between w-full max-w-4xl mb-4 px-4 text-3xl">
        <div id="player1-score">0</div>
        <div id="player2-score">0</div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="hidden absolute flex-col items-center justify-center p-8 rounded-lg modal">
        <h2 id="winnerText" class="text-4xl mb-6"></h2>
        <button id="playAgainBtn" class="btn text-2xl">Play Again</button>
    </div>

    <!-- AI Difficulty Selection Modal -->
    <div id="aiDifficultyModal" class="hidden absolute flex-col items-center justify-center p-8 rounded-lg modal">
        <h2 class="text-3xl mb-6">Select AI Difficulty</h2>
        <div class="grid grid-cols-2 gap-4">
            <button class="btn text-xl difficulty-btn" data-difficulty="beginner">Beginner</button>
            <button class="btn text-xl difficulty-btn" data-difficulty="intermediate">Intermediate</button>
            <button class="btn text-xl difficulty-btn" data-difficulty="advanced">Advanced</button>
            <button class="btn text-xl difficulty-btn" data-difficulty="expert">Expert</button>
        </div>
         <button id="backToMenuBtn" class="btn text-lg mt-6">Back</button>
    </div>

    <!-- Game Mode Selection -->
    <div id="gameModeSelection" class="absolute flex flex-col items-center justify-center p-8 rounded-lg modal">
        <h2 class="text-3xl mb-6">Choose Game Mode</h2>
        <div class="flex gap-4">
            <button id="pvpBtn" class="btn text-xl">Player vs Player</button>
            <button id="pvcBtn" class="btn text-xl">Player vs AI</button>
        </div>
    </div>


    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const player1ScoreElem = document.getElementById('player1-score');
        const player2ScoreElem = document.getElementById('player2-score');
        const gameOverModal = document.getElementById('gameOverModal');
        const winnerText = document.getElementById('winnerText');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const gameModeSelection = document.getElementById('gameModeSelection');
        const aiDifficultyModal = document.getElementById('aiDifficultyModal');
        const pvpBtn = document.getElementById('pvpBtn');
        const pvcBtn = document.getElementById('pvcBtn');
        const newGameBtn = document.getElementById('newGameBtn');
        const difficultyBtns = document.querySelectorAll('.difficulty-btn');
        const backToMenuBtn = document.getElementById('backToMenuBtn');


        // --- Game Constants ---
        const PADDLE_WIDTH = 15;
        const PADDLE_HEIGHT = 100;
        const BALL_RADIUS = 10;
        const WINNING_SCORE = 5;
        const PADDLE_SPEED = 8;
        const AI_EASING = {
            beginner: 0.06,
            intermediate: 0.08,
            advanced: 0.1,
            expert: 0.12
        };

        // --- Game State ---
        let ball, player1, player2;
        let gameActive = false;
        let keys = {};
        let gameMode = null; // 'pvp' or 'pvc'
        let aiDifficulty = null;

        // --- Utility Functions ---
        function resizeCanvas() {
            const maxWidth = 1000;
            const aspectRatio = 16 / 9;
            let width = window.innerWidth * 0.8;
            if (width > maxWidth) width = maxWidth;
            canvas.width = width;
            canvas.height = width / aspectRatio;
        }

        // --- Game Object Initialization ---
        function initGameObjects() {
            // Player 1 (left)
            player1 = {
                x: PADDLE_WIDTH,
                y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                width: PADDLE_WIDTH,
                height: PADDLE_HEIGHT,
                color: '#FFFFFF',
                score: 0,
                speed: PADDLE_SPEED
            };

            // Player 2 (right)
            player2 = {
                x: canvas.width - PADDLE_WIDTH * 2,
                y: canvas.height / 2 - PADDLE_HEIGHT / 2,
                width: PADDLE_WIDTH,
                height: PADDLE_HEIGHT,
                color: '#FFFFFF',
                score: 0,
                speed: PADDLE_SPEED // Only used for PvP mode
            };

            // Ball
            ball = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                radius: BALL_RADIUS,
                speed: 6,
                velocityX: 5 * (Math.random() > 0.5 ? 1 : -1), // Random initial direction
                velocityY: 5 * (Math.random() > 0.5 ? 1 : -1),
                color: '#FFFFFF'
            };
        }

        // --- Drawing Functions ---
        function drawRect(x, y, w, h, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
        }

        function drawCircle(x, y, r, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();
        }

        function drawNet() {
            for (let i = 0; i <= canvas.height; i += 25) {
                drawRect(canvas.width / 2 - 1, i, 2, 15, '#FFFFFF');
            }
        }

        // --- AI Logic ---
        function moveAI() {
            // The AI paddle (player2) smoothly follows the ball's y position.
            const paddleCenter = player2.y + player2.height / 2;
            
            // The easing factor determines how quickly the paddle catches up to the ball.
            // A higher difficulty means a larger factor, hence a faster, smoother reaction.
            const easingFactor = AI_EASING[aiDifficulty];
            
            // Move the paddle's center towards the ball's y-position by the easing factor.
            player2.y += (ball.y - paddleCenter) * easingFactor;
            
            // Ensure the paddle doesn't go out of bounds.
            if (player2.y < 0) {
                player2.y = 0;
            }
            if (player2.y > canvas.height - player2.height) {
                player2.y = canvas.height - player2.height;
            }
        }

        // --- Update & Render ---
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw game elements
            drawNet();
            drawRect(player1.x, player1.y, player1.width, player1.height, player1.color);
            drawRect(player2.x, player2.y, player2.width, player2.height, player2.color);
            drawCircle(ball.x, ball.y, ball.radius, ball.color);
        }

        function update() {
            if (!gameActive) return;

            // Move paddles based on pressed keys
            // Player 1 (W and S)
            if (keys['w'] && player1.y > 0) {
                player1.y -= player1.speed;
            }
            if (keys['s'] && player1.y < canvas.height - player1.height) {
                player1.y += player1.speed;
            }

            if (gameMode === 'pvp') {
                // Player 2 (ArrowUp and ArrowDown) - Only in PvP mode
                if (keys['arrowup'] && player2.y > 0) {
                    player2.y -= player2.speed;
                }
                if (keys['arrowdown'] && player2.y < canvas.height - player2.height) {
                    player2.y += player2.speed;
                }
            } else if (gameMode === 'pvc') {
                // AI controls Player 2
                moveAI();
            }

            // Move ball
            ball.x += ball.velocityX;
            ball.y += ball.velocityY;

            // Ball collision with top/bottom walls
            if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {
                ball.velocityY = -ball.velocityY;
            }

            // Ball collision with paddles
            let player = (ball.x < canvas.width / 2) ? player1 : player2;
            if (collision(ball, player)) {
                // Determine where the ball hit the paddle
                let collidePoint = (ball.y - (player.y + player.height / 2));
                collidePoint = collidePoint / (player.height / 2);

                // Calculate angle in Radian
                let angleRad = (Math.PI / 4) * collidePoint;

                // Change the X and Y velocity direction
                let direction = (ball.x < canvas.width / 2) ? 1 : -1;
                ball.velocityX = direction * ball.speed * Math.cos(angleRad);
                ball.velocityY = ball.speed * Math.sin(angleRad);

                // Speed up the ball every time a paddle is hit
                ball.speed += 0.2;
            }

            // Score points
            if (ball.x - ball.radius < 0) {
                // Player 2 scores
                player2.score++;
                updateScore();
                resetBall();
            } else if (ball.x + ball.radius > canvas.width) {
                // Player 1 scores
                player1.score++;
                updateScore();
                resetBall();
            }

            // Check for winner
            checkWinner();
        }

        function collision(b, p) {
            b.top = b.y - b.radius;
            b.bottom = b.y + b.radius;
            b.left = b.x - b.radius;
            b.right = b.x + b.radius;

            p.top = p.y;
            p.bottom = p.y + p.height;
            p.left = p.x;
            p.right = p.x + p.width;

            return b.right > p.left && b.bottom > p.top && b.left < p.right && b.top < p.bottom;
        }

        // --- Game Flow ---
        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            ball.speed = 6;
            ball.velocityX = -ball.velocityX; // Serve to the other player
            ball.velocityY = 5 * (Math.random() > 0.5 ? 1 : -1);
        }

        function updateScore() {
            player1ScoreElem.textContent = player1.score;
            player2ScoreElem.textContent = player2.score;
        }

        function checkWinner() {
            let winner = null;
            if (player1.score >= WINNING_SCORE) {
                winner = gameMode === 'pvc' ? "You Win!" : "Player 1 Wins!";
            } else if (player2.score >= WINNING_SCORE) {
                winner = gameMode === 'pvc' ? "AI Wins!" : "Player 2 Wins!";
            }
            if (winner) {
                endGame(winner);
            }
        }

        function endGame(winner) {
            gameActive = false;
            newGameBtn.classList.add('hidden');
            winnerText.textContent = winner;
            gameOverModal.classList.remove('hidden');
            gameOverModal.classList.add('flex');
        }
        
        function startGame() {
            aiDifficultyModal.classList.add('hidden');
            gameModeSelection.classList.add('hidden');
            newGameBtn.classList.remove('hidden');
            initGameObjects();
            updateScore();
            gameActive = true;
            gameLoop();
        }

        function resetGame() {
            gameActive = false;
            gameOverModal.classList.add('hidden');
            aiDifficultyModal.classList.add('hidden');
            newGameBtn.classList.add('hidden');
            gameModeSelection.classList.remove('hidden');
            gameModeSelection.classList.add('flex');
            player1.score = 0;
            player2.score = 0;
            updateScore();
            render(); // Draw the reset state
        }

        function gameLoop() {
            update();
            render();
            if (gameActive) {
                requestAnimationFrame(gameLoop);
            }
        }

        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        pvpBtn.addEventListener('click', () => {
            gameMode = 'pvp';
            startGame();
        });

        pvcBtn.addEventListener('click', () => {
            gameModeSelection.classList.remove('flex');
            gameModeSelection.classList.add('hidden');
            aiDifficultyModal.classList.remove('hidden');
            aiDifficultyModal.classList.add('flex');
        });

        difficultyBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                gameMode = 'pvc';
                aiDifficulty = btn.dataset.difficulty;
                startGame();
            });
        });

        backToMenuBtn.addEventListener('click', () => {
            aiDifficultyModal.classList.remove('flex');
            aiDifficultyModal.classList.add('hidden');
            gameModeSelection.classList.remove('hidden');
            gameModeSelection.classList.add('flex');
        });

        playAgainBtn.addEventListener('click', resetGame);
        newGameBtn.addEventListener('click', resetGame);
        
        window.addEventListener('resize', () => {
            resizeCanvas();
            // Re-initialize objects to position them correctly on the new canvas size
            if (!gameActive && gameModeSelection.classList.contains('hidden')) {
                 initGameObjects();
                 render(); // Re-render the initial state
            } else if (gameActive) {
                // If game is active, we might need a more sophisticated resize handling
                // For now, let's just re-render
                render();
            }
        });

        // --- Initial Setup ---
        resizeCanvas();
        initGameObjects(); // Initialize once for initial render
        render(); // Draw the initial state before game starts

    </script>
</body>
</html>
